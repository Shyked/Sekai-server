var Worlds = require("world").Worlds;
var Clients = require("client").Clients;
var Loader = require("loader").Loader;



var UPDATE_INTERVAL = 100;

var PLAYER_SPRITES = [
	"car_test",
	"little",
	"bloc",
	"player",
	"wisp",
	"onclick"
];



var Player = function(client, synchronizer) {

	this.worldId = null;
	this.entity = null;

	this.client = client;
	this.synchronizer = synchronizer;

	var player = this;
	this.client.addEventListener('delete', function() {
		player.clear();
	});

	var player = this;

	this.eventsIds = {
		"world": {
			"removeEntity": null
		}
	};

	this.initMessagesHandler();



	this.jumpPower = 0.5;
	this.speed = 0.9;


	this.onNicknameOk = null;
	this.client.emit('askNickname',"");

};



/****************************
  PLAYER
****************************/

Player.prototype.clear = function() {
	var world = Worlds.get(this.worldId);
	var entityId = null;
	if (this.entity) {
		var entityId = this.entity.id;
		if (world && this.entity === world.entities[this.entity.id]) this.removeEntity(world, this.entity.id);
		this.entity = null;
	}
	if (world) {
		world.removeEventListener("removeEntity", this.eventsIds["world"]["removeEntity"]);
		this.eventsIds["world"]["removeEntity"] = null;
		world.clientsId.splice(world.clientsId.indexOf(this.client.id),1);

		if (entityId != null) {
			this.broadcastToWorld('leave', JSON.stringify({
				"id": this.client.id
			}));
		}
	}
	this.worldId = null;
};





/****************************
  WORLD
****************************/

Player.prototype.goToWorld = function(worldId) {
	if (this.worldId !== null) this.clear();

	var world = Worlds.get(worldId);

	if (world) {
		this.worldId = worldId;

		world.clientsId.push(this.client.id);

		this.initIntervals();

		var player = this;
		this.eventsIds["world"]["removeEntity"] = world.addEventListener("removeEntity", function(entityId) {
			player.clearEntityDistance(entityId);
		});

		var entityJSON = Loader.loadEntitySync(PLAYER_SPRITES[Math.floor(Math.random()*PLAYER_SPRITES.length)]);
		entityJSON.x = world.spawn.x + Math.random() - 0.5;
		entityJSON.y = world.spawn.y + Math.random() - 0.5;
		if (!entityJSON.options) entityJSON.options = {};
		entityJSON.options.angle = (world.spawn.angle) ? world.spawn.angle : 0;
		this.entity = this.addEntity(world, entityJSON);
		this.entity.player = true;

		var players = [];
		var client;
		for (var id in world.clientsId) {
			client = Clients.get(world.clientsId[id]);
			players.push({
				"id": client.id,
				"nickname": client.data.player.nickname,
				"entityId": client.data.player.entity.id
			});
		}

		this.client.emit('defineWorld', JSON.stringify({
			"players": players,
			"world": world.export()
		}));

		this.broadcastToWorld('join', JSON.stringify({
			"id": this.client.id,
			"nickname": this.nickname,
			"entityId": this.entity.id
		}));
	}
};

Player.prototype.broadcastToWorld = function(type, content) {
	var world = Worlds.get(this.worldId);
	if (world) {
		var client;
		for (var id in world.clientsId) {
			client = Clients.get(world.clientsId[id]);
			if (client != this.client) client.emit(type, content);
		}
	}
};




/****************************
  MOVE
****************************/

Player.prototype.jump = function(entity) {
	if (this.entity) {

		this.player(entity);
		var type = Worlds.get(this.worldId).type;
		var vel;

		if (type == "circular") {
			var angleDistPos = toAngleDist({
				x: this.entity.physicsBody.state.pos.x,
				y: this.entity.physicsBody.state.pos.y
			});
			vel = rotatePoint(
				this.entity.physicsBody.state.vel.x, this.entity.physicsBody.state.vel.y,
				- (angleDistPos.angle + Math.PI/2),
				0, 0
			);
			if (vel.y > -this.jumpPower) vel.y = -this.jumpPower;
			vel = rotatePoint(
				vel.x, vel.y,
				(angleDistPos.angle + Math.PI/2),
				0, 0
			);
		}
		else if (type == "flat") {
			vel = {
				x: this.entity.physicsBody.state.vel.x,
				y: this.entity.physicsBody.state.vel.y
			};
			if (vel.y > -this.jumpPower) vel.y = -this.jumpPower;
		}

		this.entity.physicsBody.state.vel.x = vel.x;
		this.entity.physicsBody.state.vel.y = vel.y;

		this.entity.physicsBody.sleep(false);
		
		this.broadcastToWorld('entity', JSON.stringify(this.entity.export()));
	}
};

Player.prototype.roll = function(side, entity) {
	if (side == "left") side = -1;
	else if (side == "right") side = 1;
	else return;

	this.player(entity);

	this.entity.physicsBody.sleep(false);

	this.entity.move = {
		side: side,
		speed: this.speed
	};

	this.broadcastToWorld('entity', JSON.stringify(this.entity.export()));
};

Player.prototype.stopRoll = function(side, entity) {
	if (side == "left") side = -1;
	else if (side == "right") side = 1;
	if (this.entity.move) {
		if (this.entity.move.side == side) {
			this.player(entity);
			this.entity.move = null;
		}
	}
	this.broadcastToWorld('entity', JSON.stringify(this.entity.export()));
};




/****************************
  ENTITY
****************************/

Player.prototype.addEntity = function(world, properties) {
	var entity = world.addEntity(properties);
	//Clients.broadcast('entity', JSON.stringify(entity.export()));
	this.broadcastToWorld('world', JSON.stringify(world.export()));
	return entity;
};

Player.prototype.removeEntity = function(world, entityId) {
	world.removeEntity(entityId);
	this.broadcastToWorld('removeEntity', JSON.stringify(entityId));
};




/****************************
  MESSAGES HANDLER
****************************/

Player.prototype.initMessagesHandler = function() {
	var player = this;
	this.client.addSocketEvent('nickname', function(client, content) {player.setNickname(content);});
	this.client.addSocketEvent('mousedown', function(client, content) {player.mouseDown(content);});
	this.client.addSocketEvent('keydown', function(client, content) {player.keyDown(content);});
	this.client.addSocketEvent('keyup', function(client, content) {player.keyUp(content);});
	this.client.addSocketEvent('restartWorld', function(client, content) {player.restartWorld(content);});
	this.client.addSocketEvent('request', function(client, content) {player.requests(content);});
	this.client.addSocketEvent('player', function(client, content) {player.player(content);});
	this.client.addSocketEvent('chatboxMessage', function(client, content) {player.chatboxMessage(content);});
}

Player.prototype.setNickname = function(content) {
	var nickname = JSON.parse(content);
	if (typeof nickname !== "string") {
		this.client.emit('askNickname',"NOT_A_STRING");
	}
	else if (nickname.length === 0) this.client.emit('askNickname',"TOO_SHORT");
	else {
		if (nickname.length > 25) nickname = nickname.substr(0,25);
		this.nickname = nickname;
		if (this.onNicknameOk) this.onNicknameOk();
	}
};

Player.prototype.mouseDown = function(content) {
	var world = Worlds.get(this.worldId);
	if (world) {
		var mousePosition = JSON.parse(content);
		var entityJSON = Loader.loadEntitySync(/*"onclick"*/"car_test");
		entityJSON.x = mousePosition.x;
		entityJSON.y = mousePosition.y;
		//this.addEntity(world, entityJSON);
	}
};

Player.prototype.keyDown = function(content) {
	var data = JSON.parse(content);
	var key = data.key;
	var entity = data.entity;
	if (key == "Z" || key == "SPACE" || key == "UP") this.jump(entity);
	else if (key == "Q" || key == "LEFT") this.roll("left", entity);
	else if (key == "D" || key == "RIGHT") this.roll("right", entity);
	else if (key == "O") {
		this.entity.physicsBody.state.pos.y = -2200;
		this.entity.physicsBody.state.old.pos.y = -2200;
		this.broadcastToWorld('entity', JSON.stringify(this.entity.export()));
	}
};

Player.prototype.keyUp = function(content) {
	var data = JSON.parse(content);
	var key = data.key;
	var entity = data.entity;
	if (key == "Z" || key == "SPACE" || key == "UP") {}
	else if (key == "Q" || key == "LEFT") this.stopRoll("left", entity);
	else if (key == "D" || key == "RIGHT") this.stopRoll("right", entity);
};

Player.prototype.restartWorld = function(content) {
	var worldId = this.worldId;
	var clientsId = Worlds.get(this.worldId).clientsId.slice(0, Worlds.get(this.worldId).clientsId.length);
	for (var id in clientsId) {
		Clients.get(clientsId[id]).data.player.clear();
	}
	//var worldId = this.worldId;
	Worlds.delete(worldId);
	//this.goToWorld(worldId);
	for (var id in clientsId) {
		Clients.get(clientsId[id]).data.player.goToWorld(worldId);
	}
};

Player.prototype.requests = function(content) {
	var request = JSON.parse(content);
	if (request == "definePlayer") {
		if (this.entity) {
			this.client.emit('definePlayer', JSON.stringify({
				"entity": this.entity.export(),
				"jumpPower": this.jumpPower,
				"speed": this.speed
			}));
		}
		else {
			this.client.emit("error", JSON.stringify("The player entity does not exist yet."));
		}
	}
};

Player.prototype.player = function(content) {
	if (this.entity != null) {
		var player;
		if (typeof content == "string") player = JSON.parse(content);
		else player = content;
		this.entity.update({state: player.state});
	}
};

Player.prototype.chatboxMessage = function(content) {
	var message = JSON.parse(content);
	if (typeof message == "string") {
		if (message.substr(0,1) == "/") {
			var command = message.substr(1).split(" ");
			if (command[0] == "world") {
				try {
					Worlds.get(command[1]);
					this.client.emit("chatboxMessage", JSON.stringify({
						msg: "Going to world " + command[1],
						nickname: "World",
						color: {
							r: 30,
							g: 200,
							b: 30
						},
						type: 0
					}));
					this.goToWorld(command[1]);
				}
				catch (e) {
					this.client.emit("chatboxMessage", JSON.stringify({
						msg: "Can't find world " + command[1],
						nickname: "World",
						color: {
							r: 220,
							g: 30,
							b: 30
						},
						type: 0
					}));
				}
			}
		}
		else {
			var messageObject = {
				msg: message,
				nickname: this.nickname,
				color: {
					r: 60,
					g: 150,
					b: 255
				},
				type: 1
			};
			this.broadcastToWorld("chatboxMessage", JSON.stringify(messageObject));
			this.client.emit("chatboxMessage", JSON.stringify(messageObject));
		}
	}
};




/****************************
  INTERVALS
****************************/

Player.prototype.initIntervals = function(client) {

	this.intVars = {
		"entitiesDistance": {
			"short": {
			},
			"medium": {
			},
			"semifar": {
			}
		},

		"thresholds": {
			"short": 1000,
			"medium": 2800,
			"semifar": 5000
		},

		"recalc": {
			"short": 24,
			"medium": 8,
			"semifar": 8,
			"far": 40
		},

		"update": {
			"short": 5,
			"medium": 5,
			"semifar": 0,
			"far": 0 // 0 for never
		},

		"count": 0
	};

	var player = this;

	this.client.clearInterval("worldUpdate");
	this.client.setInterval("worldUpdate", function(client) {
		player.recalcDistanceInterval();
	}, UPDATE_INTERVAL);

};

Player.prototype.recalcDistanceInterval = function() { // will recalc short and medium more often than far
	var world = Worlds.get(this.worldId);

	if (world && this.entity) {
		var dist;

		var entities = {};

		// Add to entities the entitites that need to be recalculated
		if (this.intVars.count % this.intVars.recalc.far == 0) {
			entities = world.entities;
		}
		else {
			if (this.intVars.count % this.intVars.recalc.semifar == 0) {
				for (var idE in this.intVars.entitiesDistance.semifar) {
					entities[idE] = this.intVars.entitiesDistance.semifar[idE];
					delete this.intVars.entitiesDistance.semifar[idE];
				}
			}
			if (this.intVars.count % this.intVars.recalc.medium == 0) {
				for (var idE in this.intVars.entitiesDistance.medium) {
					entities[idE] = this.intVars.entitiesDistance.medium[idE];
					delete this.intVars.entitiesDistance.medium[idE];
				}
			}
			if (this.intVars.count % this.intVars.recalc.short == 0) {
				for (var idE in this.intVars.entitiesDistance.short) {
					entities[idE] = this.intVars.entitiesDistance.short[idE];
					delete this.intVars.entitiesDistance.short[idE];
				}
			}
		}

		for (var idE in entities) {
			dist = this.distFromEntity(entities[idE]);
			if (dist < this.intVars.thresholds.short) {
				this.intVars.entitiesDistance.short[idE] = entities[idE];
			}
			else if (dist < this.intVars.thresholds.medium) {
				this.intVars.entitiesDistance.medium[idE] = entities[idE];
			}
			else if (dist < this.intVars.thresholds.semifar) {
				this.intVars.entitiesDistance.semifar[idE] = entities[idE];
			}
		}

		if (this.intVars.count % this.intVars.update.far == 0) this.worldUpdateInterval("far");
		else if (this.intVars.count % this.intVars.update.semifar == 0) this.worldUpdateInterval("semifar");
		else if (this.intVars.count % this.intVars.update.medium == 0) this.worldUpdateInterval("medium");
		else if (this.intVars.count % this.intVars.update.short == 0) this.worldUpdateInterval("short");

		this.intVars.count++;
	}
};
Player.prototype.distFromEntity = function(entity) { // possible optimization : if aabb < ? use only x & y
	var playerEntity = this.entity;

	if (entity == playerEntity) return 0;

	var dx = entity.physicsBody.state.pos.x - playerEntity.physicsBody.state.pos.x;
	var dy = entity.physicsBody.state.pos.y - playerEntity.physicsBody.state.pos.y;

	var aabbPlayer = playerEntity.physicsBody.aabb();
	var aabbEntity = entity.physicsBody.aabb();

	var aabbdx = (aabbEntity.x - aabbEntity.hw * Math.sign(dx)) - (aabbPlayer.x + aabbPlayer.hw * Math.sign(dx));
	var aabbdy = (aabbEntity.y - aabbEntity.hh * Math.sign(dy)) - (aabbPlayer.y + aabbPlayer.hh * Math.sign(dy));

	if (aabbdx * Math.sign(dx) < 0 && aabbdy * Math.sign(dy) < 0) return 0;
	else if (aabbdx * Math.sign(dx) < 0) return Math.abs(aabbdy);
	else if (aabbdy * Math.sign(dy) < 0) return Math.abs(aabbdx);

	return Math.sqrt(aabbdx * aabbdx + aabbdy * aabbdy);
};

Player.prototype.clearEntityDistance = function(entityId) {
	if (this.intVars.entitiesDistance.short[entityId]) delete this.intVars.entitiesDistance.short[entityId];
	if (this.intVars.entitiesDistance.medium[entityId]) delete this.intVars.entitiesDistance.medium[entityId];
	if (this.intVars.entitiesDistance.semifar[entityId]) delete this.intVars.entitiesDistance.semifar[entityId];
};

Player.prototype.worldUpdateInterval = function(range) {

	var world = Worlds.get(this.worldId);

	if (world) {

		var entities = {};

		if (range == "far") {
			entities = world.export().entities;
		}

		if (range == "semifar") {
			for (var id in this.intVars.entitiesDistance.semifar) {
				entities[id] = this.intVars.entitiesDistance.semifar[id].export();
			}
		}

		if (range == "medium" || range == "semifar") {
			for (var id in this.intVars.entitiesDistance.medium) {
				entities[id] = this.intVars.entitiesDistance.medium[id].export();
			}
		}

		if (range == "short" || range == "medium" || range == "semifar") {
			for (var id in this.intVars.entitiesDistance.short) {
				entities[id] = this.intVars.entitiesDistance.short[id].export();
			}
		}

		this.client.emit('world', JSON.stringify({
			"id": this.worldId,
			"entities": entities
		}));

	}

};







exports.Player = Player;




// Lib

function toAngleDist(pos) {
	if (pos.x != 0 || pos.y != 0) {
		var dist = Math.sqrt(pos.x * pos.x + pos.y * pos.y);
		var angle = Math.acos(pos.x / dist);
		if (pos.y < 0) angle = -angle;
		return {
			angle: angle,
			dist: dist
		};
	}
	else {
		return {
			angle: 0,
			dist: 0
		};
	}
}

function toXY(angleDist) {
	var x = Math.cos(angleDist.angle) * angleDist.dist;
	var y = Math.sin(angleDist.angle) * angleDist.dist;
	return {
		x: x,
		y: y
	};
}

function rotatePoint(x, y, angle, centerX, centerY) { // http://stackoverflow.com/questions/11332188/javascript-rotation-translation-function
	x -= centerX;
	y -= centerY;
	var point = {};
	point.x = x * Math.cos(angle) - y * Math.sin(angle);
	point.y = x * Math.sin(angle) + y * Math.cos(angle);
	point.x += centerX;
	point.y += centerY;
	return point;
}

function inArray(needle, haystack) {
    for (var id in haystack) {
        if (haystack[id] == needle) return true;
    }
    return false;
}