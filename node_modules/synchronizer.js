(function() {


	var Worlds = require("world").Worlds;
	var Clients = require("client").Clients;

	var Synchronizer = function() {
		this.startingWorldId = null;
	};

	Synchronizer.prototype.init = function(startingWorldId) {
		this.startingWorldId = startingWorldId;

		var that = this;
		Clients.addEventListener('new', function(client) {
			client.data.worldId = startingWorldId;
			client.emit('defineWorld', JSON.stringify(Worlds.get(client.data.worldId).exportForJSON()));
			client.setInterval(function() {
				client.emit('world', JSON.stringify(Worlds.get(client.data.worldId).exportForJSON()));
			}, 4000)
			client.addSocketEvent('mousedown', that.mouseDown);
		});
	};

	Synchronizer.prototype.addEntity = function(world, shape, properties) {
		var entity = world.addEntity(shape, properties);
		//Clients.broadcast('entity', JSON.stringify(entity.exportForJSON()));
		Clients.broadcast('world', JSON.stringify(Worlds.get(1).exportForJSON()));
		/*

		1. Lors de l'ajout d'une entité, update tout le monde
		2. Ou alors, lorsqu'il y a collision avec une entité non statique (avec une force minimum) renvoyer ces deux (ou plus) entités

		La collision c'est le moment où une légère désynchro risque de tout chambouler.

		Il faudra penser à optimiser les objets côté client, il y a sûrement certains objets qui devraient être effacés et qui ne le sont pas.

		*/
	};

	Synchronizer.prototype.mouseDown = function(client, content) {
		var mousePosition = JSON.parse(content);
		singleSynchronizer.addEntity(Worlds.get(client.data.worldId), 'Circle', {
			x: mousePosition.x,
			y: mousePosition.y,
			radius: 25,
			options: {
				restitution: 0.6
			},
			texture: "ball",
			textureScale: {x: 1, y: 1}
		});
		/*singleSynchronizer.addEntity(Worlds.get(client.data.worldId), 'Rectangle', {
			x: mousePosition.x,
			y: mousePosition.y,
			width: 30,
			height: 30,
			options: {
				restitution: 0.5
			}
		});*/
	}


	var singleSynchronizer = new Synchronizer();
	exports.Synchronizer = singleSynchronizer;


})();